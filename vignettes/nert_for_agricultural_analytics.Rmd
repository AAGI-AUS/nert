---
title: "Use nert to augment agricultural analytics with SMIPS data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Use nert to augment agricultural analytics with SMIPS data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitrsetup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

The TERN Soil Moisture Integration and Prediction System (SMIPS) generates
useful measurements of soil moisture at 1km resolution across all of Australia.
TERN provides this soil moisture information as packaged daily datasets [via
their TERN Data Portal](https://data.tern.org.au/model-derived/smips/), in
cloud-optimised GeoTIFF format. The **nert** package provides ease of access
to these SMIPS datasets for use and inclusion in R data analytics workflows.

This document introduces you to the **nert** package, including setup and
how to use the package to download SMIPS data for given locational coordinates
in Australia. The document then showcases an example of a grain production
experiment, and how we can use **nert** and the SMIPS soil moisture readings
to improve our analytics and modelling.

## Setup: Acquire and specify your TERN API key

An API key is required to access TERN datasets (including SMIPS) through 
their online data portal. The **nert** package streamlines the data process,
but still requires authorisation using an API key. However, it is
straightforward to sign up to the TERN Data Portal and acquire an API key that
you can use, and by setting it in your R environment (via `.Renviron`) you
can provide the **nert** package with that credential to allow convenient
access.

The following steps detail the process for signing in to your TERN account,
generating an API key, and storing it in your R environment:

1. Navigate to the TERN Data Discovery Portal (https://portal.tern.org.au/) in 
 a web browser, and click the "Sign in" button that appears in the top-right
 of the browser window.
 
    ![](nert_for_agricultural_analytics_tern_apikey_1.jpg){width=80%}
    
1. Click the Australian Access Federation button to sign in to the TERN Data
    Portal via your University ID (or alternatively, sign in via CILogon or
    your Google identity).
 
    ![](nert_for_agricultural_analytics_tern_apikey_2.jpg){width=80%}
    
1. Once signed in, click on the menu in the top-right with your name and click
    the "TERN Account" entry to open your account profile.
 
    ![](nert_for_agricultural_analytics_tern_apikey_4.jpg){width=80%}
    
1. On your account profile screen, navigate to the menu on the left-hand side,
    and click the "Create API key" entry.
 
    ![](nert_for_agricultural_analytics_tern_apikey_5.jpg){width=80%}
    
1. On this screen you can create your API key for accessing the TERN Data
    Portal. Give your key whatever name you like (e.g., below I have called
    the key "my_API_key" for demonstration purposes), and then click the
    "Request API Key" button.
 
    ![](nert_for_agricultural_analytics_tern_apikey_6.jpg){width=80%}
    
1. Your API key is now generated and appears as the string of text inside the
    text box on the page, together with the key's creation and expiration
    dates. Copy the API key to your clipboard, so that we can paste it into
    the `.Renvion` file in the next step.
 
    ![](nert_for_agricultural_analytics_tern_apikey_7.jpg){width=80%}
    
1. Open your `.Renviron` file (e.g., if you are using RStudio, an easy way to
    open the right file is to enter `usethis::edit_r_environ()`). Add a new
    line to the file to store your API key in the variable `TERN_API_KEY`:
    
    ```
    TERN_API_KEY='<paste your key here>'
    ```
 
    ![](nert_for_agricultural_analytics_tern_apikey_8.jpg){width=80%}
    
1. Save your `.Renviron` file, and restart your R session so that the change is 
    applied. You can then test that the **nert** package is reading your API 
    key properly by entering `nert::get_key()()` at the R command console. If the
    API key was successfully read by **nert**, then you should see your API key
    appear verbatim as output.
 
    ![](nert_for_agricultural_analytics_tern_apikey_9.jpg){width=80%}

1. Finally, you can quickly test that the data download from the TERN portal 
    is working as intended by downloading a test data raster. The below code
    downloads the SMIPS "totalbucket" soil moisture data raster for January 1st
    2024, and uses the **terra** package's `extract` function to get a point 
    value for the soil moisture measurement at the Adelaide CBD (at 
    approximately -34.9285 decimal degrees latitude, 138.6007 longitude):
    
    ```{r testnertcache, include = FALSE}
    library(nert)
    adelaide <- readRDS("cache_adelaide.rds")
    ```
    
    ```{r testnert, eval = FALSE}
    library(nert)
    r <- read_smips(day = "2024-01-01")
    terra::extract(r, xy = TRUE, data.frame(lon = 138.6007, lat = -34.9285))
    ```
    ```{r testnertresults, echo = FALSE}
    adelaide
    ```

At this stage your **nert** package is now working, and you can use it to
easily download SMIPS datasets from the TERN Data Portal. The rest of this
vignette shows how you can use this downloaded soil moisture data to augment
analytics, using a fictitious grain production experiment as an illuminating
example.

## A synthetic dataset for a grain production experiment

To showcase how to use the **nert** package and the TERN SMIPS soil moisture
data to augment the analytics of an agronomics experiment, a simulated
dataset containing yield data for a fictitious grain production experiment has
been included with the **nert** package. The dataset is called `grain`, and 
you can load this dataset with:

```{r loaddata}
data(grain)
str(grain)
```

The `grain` dataset supposes that a fabricated grain production experiment has
been run at a selection of ten sites across South Australia, looking at the
effects of four different treatment levels of Nitrogen application and three 
different seeding rates on the grain yield for some crop with eight varieties.

Note that we have locational coordinates (in `Latitude` and
`Longitude`) for each of the sites, as well as dates for the crop sowing and 
Nitrogen applications (in `SowDate` and `NitrogenDate` respectively.) This
spatiotemporal information is useful, as it allows us to match up the
experimental sites with the data points that we need to download from SMIPS.

## Download SMIPS data for the sites across times

Here we will use the **nert** package to download SMIPS soil moisture datasets
from the TERN Data Portal, which we can use to augment our analysis of 
the `grain` experiment data. The two key SMIPS datasets of interest are:

1. `totalbucket`: an estimate of the _volumetric soil moisture_ (in units of mm)
  from the SMIPS bucket moisture store,

1. `SMindex`: the SMIPS _soil moisture index_ (i.e., a number between 0 and 1
  that indicates how full the SMIPS bucket moisture store is relative to
  its 90cm capacity).

For simplicity, suppose we are interested in the SMIPS soil moisture index 
(`SMindex`) data, for all days falling between the earliest Nitrogen 
application date up to 30 days after the last application date, and we want the
soil moisture index at each site (by latitude/longitude coordinates). We can
generate this date range in a straightforward way using the `NitrogenDate`
column of the `grain` dataset as follows:
```{r daterange}
start_date <- min(grain$NitrogenDate)
end_date <- max(grain$NitrogenDate) + 30
date_range <- seq(start_date, end_date, by = "1 day")

c(date_range[1], date_range[length(date_range)])
```

We also need the latitude and longitude for the sites, which we can readily 
retrieve from the `grain` dataset columns `Latitude` and `Longitude`:
```{r siteslist}
sites <- unique(grain[ , c("Site", "Latitude", "Longitude")])
sites
```

Now TERN supplies the SMIPS daily data rasters as cloud-optimised GeoTIFFs 
(or COGs), which contain the soil moisture point predictions across the
entirety of Australia. However, because they are cloud-optimised, we can be
clever in our downloading to make sure that we only download data for the
locations of interest, rather than the entire raster. The **nert** package works
in tandem with the **terra** package to achieve this efficiency:

- First, we download the _information_ for a daily SMIPS raster 
    using `nert::read_smips`,
- Then we _extract only the point values we need_, using `terra::extract`.

This leads to a quicker and tighter data download. The below code shows
this process. (Note that `terra::extract` is particular about the order
of the latitude/longitude coordinates: longitude should be specified first,
followed by latitude.)

```{r downloadsmipscache, include = FALSE}
smips_data <- readRDS("cache_smips_data.rds")
```

```{r downloadsmips, eval = FALSE}
smips_data <- data.frame()
for (i in 1:length(date_range)) {
  r <- read_smips(collection = "SMindex", day = date_range[i])
  smips_points <- terra::extract(
    x = r,
    y = data.frame(lon = sites$Longitude, lat = sites$Latitude),
    xy = TRUE
  )
  names(smips_points)[2] <- "smips_smi_perc"

  smips_data <- rbind(
    smips_data,
    data.frame(
      Date = date_range[i],
      Latitude = smips_points$y,
      Longitude = smips_points$x,
      smips_smi_perc = smips_points$smips_smi_perc
    )
  )
}
head(smips_data)
```

```{r downloadsmipsresults, echo = FALSE}
head(smips_data)
```

We can add the `Site` column to the `smips_data` to make it easier to use it
in conjunction with the `grain` dataset during the analysis:

```{r addbacksite}
smips_data$Site <- sites$Site
head(smips_data)
```

We are now ready to proceed with the analytics.

## A simple model for grain yield

First, we model the grain yield with a simple model without taking into account
any soil moisture confounding---that is, without reference to the SMIPS data
that we have just downloaded. We will later incorporate the SMIPS data to see
how including the soil moisture as a covariate improves the modelling.

Here we will use the **nlme** package to fit a linear mixed-effect model. The
grain yield `Yield_tha` will be modelled taking the `Variety`, Nitrogen
application rate `Nitrogen_kgNha` and seeding rate `SeedRate_plantsm2` as fixed
terms, and incorporating the `Site` and replicate (`Rep`) structure of the
experiment in a random effect term.

```{r simplemodel}
library(nlme)
simple_model <- lme(
  fixed = Yield_Tha ~ Variety * Nitrogen_kgNha * SeedRate_plantsm2,
  random = ~ 1 | Site/Rep,
  data = grain
)
```

We can check the confidence intervals for the effect sizes of the 
Nitrogen treatments for this simple model:
```{r simplemodeleffects}
simple_model.ints <- intervals(simple_model, which = "fixed")$fixed
simple_model.Neffects <- simple_model.ints[paste0("Nitrogen_kgNha", c(30, 60, 90)), ]
simple_model.Neffects
```

## Augment the yield model with soil moisture data

Next, we augment our modelling by including the SMIPS soil moisture data
as a covariate (perhaps anticipating that the soil moisture improves the
yield, but might reduce the effect of Nitrogen applied to the soil due
to volatilisation). To keep things simple, for each site (and its 
associated Nitrogen application date) we take an average of the SMIPS-reported
soil moisture index from the date of the Nitrogen application until 30 days
after the application, which we will store in a new column called
`SoilMoisture_avg`.

```{r smipsaverage}
for (site in sites$Site) {
  start_date <- unique(grain[which(grain$Site == site), "NitrogenDate"])[1]
  dates <- seq(start_date, start_date + 30, by = "1 day")
  smips <- smips_data[which(smips_data$Site == site & smips_data$Date %in% dates), ]
  smips_avg <- mean(smips[["smips_smi_perc"]])
  grain[which(grain$Site == site), "SoilMoisture_avg"] <- smips_avg
}
```

We can then add this average soil moisture as a fixed effect to the linear
mixed-effect model:

```{r augmentedmodel}
augmented_model <- lme(
  fixed = Yield_Tha ~ Variety * Nitrogen_kgNha * SeedRate_plantsm2 
    + SoilMoisture_avg + SoilMoisture_avg:Nitrogen_kgNha,
  random = ~ 1 | Site/Rep,
  data = grain
)

```

The confidence intervals for the effect sizes of the Nitrogen application
treatments for this augmented model are then as follows:

```{r augmentedmodeleffects}
augmented_model.ints <- intervals(augmented_model, which = "fixed")$fixed
augmented_model.Neffects <- augmented_model.ints[paste0("Nitrogen_kgNha", c(30, 60, 90)), ]
augmented_model.Neffects
```

We can use **ggplot2** plotting to graph the confidence intervals for the 
simple model versus the augmented model, and illuminate the difference 
attained when we include the soil moisture as a confounding term in our 
modelling:

```{r ploteffects, fig.width = 7, fig.align="center", out.width="100%"}
library(ggplot2)

ci <- rbind(
  data.frame(simple_model.Neffects, model = "Simple Model"),
  data.frame(augmented_model.Neffects, model = "SMIPS-Augmented Model")
)
ci$term <- paste0("Nitrogen_kgNha", c(30, 60, 90))

pd <- position_dodge(0.4)
ggplot(ci, aes(x = est., y = term, colour = model)) +
  geom_point(position = pd) +
  geom_errorbarh(aes(xmin = lower, xmax = upper), position = pd, height = 0.2) +
  labs(y = "predictor", x = "estimate")
```

From the comparison of the effect sizes for the Nitrogen treatment, we can
see that the simple model underestimates the treatment effect. The
augmented model, in contrast, accounts for the soil moisture and the potential
Nitrogen vaporisation that may occur in high soil moisture conditions.
